scopeName: 'text.tex.latex'
name: 'LaTeX2e'
fileTypes: [
  'tex'
]

limitLineLength: false

# Rules to be implemented. Please add to repository and link to a 'meta' to include.
# The following rules correspond to the ten special latex characters
patterns: [
  {
    include: '#controlMeta'
  }
  {
    include: '#percentMeta'
  }
  {
    include: '#dollarMeta'
  }
  {
    include: '#tildeMeta'
  }
  {
    include: '#ampersandMeta'
  }
  {
    include: '#openCurlyBracketMeta'
  }
  {
    include: '#closeCurlyBracketMeta'
  }
  {
    include: '#underscoreMeta'
  }
  {
    include: '#caretMeta'
  }
  {
    include: '#hashtagMeta'
  }
]

# List of available rules. Must 'include' a rule to patterns for it to be implemented.
# Thinking of moving pure TeX commands to a separate file and linking it in here (like the preexisting package).
repository:
# Meta Commands
  controlMeta: {
    comment: 'This is (ideally) called when a backslash is found.'
    patterns: [
      {
        include: '#doubleBackslash'
      }
      {
        include: '#escapedCharacter'
      }
      {
        include: '#displayMathMode'
      }
      {
        include: '#documentclass'
      }
      {
        include: '#usepackage'
      }
      {
        include: '#inputFile'
      }
      {
        include: '#documentEnvironment'
      }
      {
        include: '#figureEnvironment'
      }
      {
        include: '#mathEnvironmentMeta'
      }
      {
        include: '#genericEnvironment'
      }
      {
        include: '#sectioning'
      }
      {
        include: '#makeatsomething'
      }
      {
        include: '#verbatim'
      }
      {
        include: '#item'
      }
      {
        include: '#texPrimitives'
      }
      {
        include: '#controlSymbol'
      }
      {
        include: '#controlWord'
      }
    ]
  }
  percentMeta: {
    comment: 'This is called when there is a lone percent sign (escaped covered by controlMeta).'
    patterns: [
      {
        comment: 'Should work so long it is the end of any comment; eg. % other% !TEX = ...'
        include: '#magicComment'
      }
      {
        include: '#lineComment'
      }
    ]
  }
  dollarMeta: {
    comment: 'Called when $ sign found'
    patterns: [
      {
        include: '#displayMathMode'
      }
      {
        include: '#inlineMathMode'
      }
    ]
  }
  tildeMeta: {
    comment: 'This is only an unbreaking space (when alone).'
    name: 'punctuation.space.latex'
    match: '~'
  }
  ampersandMeta: {
    comment: 'The ampersand normally represents alignment (catcode 4). Probably not useful (or legal) outside of align or table environment. However, it must be left this way to let users implement custom environments.'
    name: 'punctuation.alignment.latex'
    match: '&'
  }
  openCurlyBracketMeta: {
    contentName: 'variable.parameter.argument.latex'
    begin: '{'
    beginCaptures:
      0:
        name: 'punctuation.definition.argument.latex'
    end: '}'
    endCaptures:
      0:
        name: 'punctuation.definition.argument.latex'
    patterns: [
      comment: 'Optimisation good to implement here. Rework commentMeta to be a more general check for escaped characters and comments'
      {
        include: '#escapedCharacter' # for an escaped %
      }
      {
        include: '#lineComment'
      }
      {
        include: '$base'
      }
    ]
  }
  closeCurlyBracketMeta: {
    comment: 'To reach this means unbalanced brackets: THIS IS AN ERROR.'
    name: 'invalid.illegal.latex'
    match: '}'
  }
  underscoreMeta: {
    comment: 'Underscore means subscript. It will take an argument in brackets if possible. If not, just the single next character. Only valid when within mathmode. Will address this later.'
    patterns: [
      {
        include: '#underscoreWithArgument'
      }
      {
        include: '#underscoreNoArgument'
      }
    ]
  }
  underscoreWithArgument: {
    comment: 'Matches an underscore and between curly brackets'
    name: 'punctuation.subscript.latex'
    begin: '_\\s*(?={)'
    end: '(?<=\\})'
    patterns: [
      {
        include: '#argumentScope'
      }
    ]
  }
  underscoreNoArgument: {
    comment: 'Matches an underscore and next character or macro. Considering making this give a warning, as brackets is best practice'
    name: 'punctuation.subscript.latex'
    match: '_\\s*(\\\\[a-zA-Z]+|\\\\[.]|.)?'
  }
  caretMeta: {
    comment: 'Like underscore, but superscript'
    patterns: [
      {
        include: '#caretWithArgument'
      }
      {
        include: '#caretNoArgument'
      }
    ]
  }
  caretWithArgument: {
    comment: 'Matches a caret and between curly brackets'
    name: 'punctuation.superscript.latex'
    begin: '\\^\\s*(?={)'
    end: '(?<=\\})'
    patterns: [
      {
        include: '#argumentScope'
      }
    ]
  }
  caretNoArgument: {
    comment: 'Matches a caret and next character or macro. Considering making this give a warning, as brackets is best practice'
    name: 'punctuation.superscript.latex'
    match: '\\^\\s*(\\\\[a-zA-Z]+|\\\\[.]|.)?'
  }
  hashtagMeta: {
    comment: 'I dont like calling this the pound symbol. Catcode says it is a parameter identifier.'
    match: '(\\#{3,}[0-9]+)|(\\#{2}[0-9]+)|(\\#[0-9]+)'
    captures:
      1:
        name: 'variable.parameter.hashtag.3.latex'
      2:
        name: 'variable.parameter.hashtag.2.latex'
      3:
        name: 'variable.parameter.hashtag.1.latex'
  }
# Other
  escapedCharacter: {
    comment: 'Finds escaped characters like \$ and \%. Uses this regex so unique capture groups can be used.'
    name: 'constant.character.latex'
    match: '\\\\(\\&|\\%|\\$|\\#|\\_|\\{|\\}|(textascii(tilde|circum)|textbackslash)(?=[^a-zA-Z@]))'
  }
  controlSymbol: {
    comment: 'Mostly covered by escapedCharacter, but this is a catch all for any contol symbols'
    name: 'keyword.control.symbol.latex'
    match: '\\\\[^a-zA-Z]'
  }
  controlWord: {
    comment: 'A catch all for latex control words that have not already been identified.'
    name: 'support.function.general.latex'
    match: '\\\\[a-zA-Z]+'
  }
  accents: {
    comment: 'For standard latex accent macros such as \^ or \`. Not used for now, at least until better rules are developed.'
    name: 'constant.character.accent.latex'
    match: '''\\\\([\\`\\'\\^\\"\\~\\=\\.]\\s*(\\w|\\{\\w?\\})|[Hcklbdruv]\\{\\w?\\})'''
  }
  hypersetup: {
    comment: 'Recongnises hypersetup environment. Can be extended to be a general key-option scoper, but this (potentially) allows custom colours for known keys.'
    name: 'meta.preamble.latex'
    begin: '\\\\hypersetup(?=[^a-zA-Z@])'
    beginCaptures:
      0:
        name: 'keyword.control.preamble.hypersetup.latex'
    end: '(?<=\\})|(^\\s*$)'
    endCaptures:
      1:
        name: 'invalid.illegal.latex'
    patterns: [
      {
        include: '#argumentScope'
      }
    ]
  }
  lineComment: {
    comment: 'Line comment. This will find an available % sign and match it to just before another % (where it looks for a magic comment) or the end.'
    name: 'comment.line.percentage.latex'
    begin: '%'
    end: '(?=%)|$'
  }
  escapedCurlyBracket: {
    comment: 'Escaped }. Possible deprecated by escapedCharacter.'
    name: 'constant.character.latex'
    match: '\\\\}|\\\\{'
  }
  usepackage: {
    comment: 'Package finder. Similar to documentclass, but allows custom colours. A macro name is only valid with letters (exceptions apply--eg. makeatletter). This checks to see if the name is purely "usepackage" and the following character is not a legal part of the macro name.'
    name: 'meta.preamble.latex'
    begin: '\\\\usepackage(?=[^a-zA-Z@])'
    beginCaptures:
      0:
        name: 'keyword.control.preamble.latex'
    end: '(?<=\\})|(^\\s*$)'
    endCaptures:
      1:
        name: 'invalid.illegal.latex'
    patterns:[
      {
        include: '#awaitingArgumentBrackets'
      }
      {
        comment: 'Only this one necessary because escaped characters will be picked up by awaitingArgumentBrackets.'
        include: '#lineComment'
      }
      {
        comment: 'Will try and find optional arguments first.'
        include: '#optionalArgumentScope'
      }
      {
        include: '#argumentScope'
      }
    ]
  }
  sectioning: {
    comment: 'Covers all sectioning commands such as section, subsection, subparagraph, etc.'
    name: 'support.function.section.latex'
    begin: '\\\\((sub){0,2}section|(sub){0,1}paragraph|part|chapter)(\\*)?(?=[^a-zA-Z@])'
    beginCaptures:
      0:
        name: 'entity.name.section.tex'
    end: '(?<=\\})|(^\\s*$)'
    endCaptures:
      1:
        name: 'invalid.illegal.latex'
    patterns: [
      {
        include: '#awaitingArgumentBrackets'
      }
      {
        comment: 'Only this one necessary because escaped characters will be picked up by awaitingArgumentBrackets.'
        include: '#lineComment'
      }
      {
        comment: 'Will try and find optional arguments first.'
        include: '#optionalArgumentScope'
      }
      {
        include: '#argumentScope'
      }
    ]
  }
  doubleBackslash: {
    match: '\\\\\\\\'
    name: 'punctuation.break.latex'
  }
  commentMeta: {
    comment: 'Main purpose is to distinguish escaped % from comments. Deprecated.'
    patterns: [
      {
        include: '#doubleBackslash'
      }
      {
        include: '#escapedCharacter'
      }
      {
        include: '#magicComment'
      }
      {
        include: '#lineComment'
      }
    ]
  }
  magicComment: {
    comment: 'Can be improved to change color depending if the command matches a known string'
    name: 'keyword.control.magic.latex'
    match: '''(?x)   # Allow comments like this
     ((        # Capture groups 1 & 2
       (%)     # Capture percent sign
       (\\ !(?>TEX|BIB)\\ )  # Exact match required
       (\\S+)    # A word (this is required as far as I know)
       )       # End capture group 2
       (\\ = \\ )  # Match = with space (required)
     )         # End capture group 1
     .*$       # To end; some options have spaces
   '''
  }
  documentclass: {
    comment: 'Documentclass finder.'
    name: 'meta.preamble.latex'
    begin: '\\\\documentclass(?=[^a-zA-Z@])'
    beginCaptures:
      0:
        name: 'keyword.control.preamble.latex'
    end: '(?<=\\})|(^\\s*$)'
    endCaptures:
      1:
        name: 'invalid.illegal.latex'
    patterns:[
      {
        include: '#awaitingArgumentBrackets'
      }
      {
        include: '#lineComment'
      }
      {
        include: '#optionalArgumentScope'
      }
      {
        include: '#argumentScope'
      }
    ]
  }
  awaitingArgumentBrackets: {
    comment: 'Anything not whitespace, opening bracket or comment will be flagged as invalid.illegal. Should take priority over other matches (even comments, as comments have the escaped % exception).'
    match: '[^{\\[\\s%]+'
    name: 'invalid.illegal.latex'
  }
  optionalArgumentScope: {
    comment: 'Matches options brackets and everything inside them.'
    contentName: 'variable.parameter.optional.latex'
    begin: '\\['
    beginCaptures:
      0:
        name: 'punctuation.definition.optional.begin.latex'
    end: '\\]'
    endCaptures:
      0:
        name: 'punctuation.definition.optional.end.latex'
    patterns: [
      {
        comment: 'AFAIK, the optional parameters never have nested brackets. Will come back to this after a while or if I find they do.'
        include: '#commentMeta'
      }
      {
        include: '#escapedCurlyBracket'
      }
      {
        include: '#openCurlyBracketMeta'
      }
    ]
  }
  argumentScope: {
    comment: 'Matches arguments brackets (the outmost of nested brackets). Specifically for commands like usepackage.'
    contentName: 'variable.parameter.argument.latex'
    begin: '\\{'
    beginCaptures:
      0:
        name: 'punctuation.definition.argument.begin.latex'
    end: '\\}'
    endCaptures:
      0:
        name: 'punctuation.definition.argument.end.latex'
    patterns: [
      {
        include: '#commentMeta'
      }
      {
        include: '#escapedCurlyBracket'
      }
      {
        include: '#openCurlyBracketMeta'
      }
    ]
  }
  nestedSquareBrackets: {
    contentName: 'variable.parameter.optional.latex'
    begin: '\\['
    beginCaptures:
      0:
        name: 'punctuation.definition.optional.begin.latex'
    end: '\\]'
    endCaptures:
      0:
        name: 'punctuation.definition.optional.end.latex'
    patterns: [
      comment: 'Optimisation good to implement here. Rework commentMeta to be a more general check for escaped characters and comments'
      {
        include: '#commentMeta'
      }
      {
        include: '#escapedCloseSquareBracket'
      }
      {
        include: '#nestedSquareBrackets'
      }
    ]
  }
  endArgumentsMeta: {
    patterns: [
      {
        include: '#doubleBackslash'
      }
      {
        include: '#escapedCurlyBracket'
      }
    ]
  }
  inlineMathMode: {
    comment: 'This can be triggered using $ or \( \). Both can be used in the same pair.'
    contentName: 'string.other.math.inline.latex'
    begin: '(\\$)|(\\\\\\()'
    beginCaptures:
      0:
        name: 'string.other.math.inline.begin.latex'
    end: '(\\$)|(\\\\\\))'
    endCaptures:
      0:
        name: 'string.other.math.inline.end.latex'
    patterns: [
      {
        include: '#commentMeta'
      }
      {
        comment: 'Mathmode special characters are different to text; eg. textbackslash is not allowed'
        name: 'constant.character.latex'
        match: '\\\\\\$'
      }
      {
        comment: 'When in inline math, the exit can only be $ or \)'
        name: 'invalid.illegal.latex'
        match: '(\\\\(\\[|\\(|\\)))'
      }
      {
        include: '$base'
      }
    ]
  }
  displayMathMode: {
    comment: 'This can be triggered using $$ or \[ \]. Both can be used in the same pair.'
    contentName: 'string.other.math.display.latex'
    begin: '(\\$\\$)|(\\\\\\[)'
    beginCaptures:
      0:
        name: 'string.other.math.display.begin.latex'
      1:
        name: 'invalid.deprecated.latex'
    end: '(\\$\\$)|(\\\\\\])'
    endCaptures:
      0:
        name: 'string.other.math.display.end.latex'
      1:
        name: 'invalid.deprecated.latex'
    patterns: [
      {
        include: '#commentMeta'
      }
      {
        comment: 'Mathmode special characters are different to text; eg. textbackslash is not allowed'
        name: 'constant.character.latex'
        match: '\\\\\\$'
      }
      {
        comment: 'When in display math, the exit can only be $$ or \]'
        name: 'invalid.illegal.latex'
        match: '(?<=[^\\\\])(\\$)(?=[^\\$])|(\\\\(\\[|\\(|\\)))'
      }
      {
        include: '$base'
      }
    ]
  }
  genericEnvironment: {
    comment: 'Matches environments not recognised by other rules. Less lenient with random formatting here, it is expected to all be on one line.'
    contentName: 'meta.environment.latex'
    begin: '\\\\begin(\\{)([\\w \\*]*)(\\})'
    beginCaptures:
      0:
        name: 'support.function.environment.begin.latex'
      1:
        name: 'punctuation.definition.argument.begin.latex'
      2:
        name: 'variable.parameter.argument.latex'
      3:
        name: 'punctuation.definition.argument.end.latex'
    end: '\\\\end(\\{)(\\2)(\\})'
    endCaptures:
      0:
        name: 'support.function.environment.end.latex'
      1:
        name: 'punctuation.definition.argument.begin.latex'
      2:
        name: 'variable.parameter.argument.latex'
      3:
        name: 'punctuation.definition.argument.end.latex'
    patterns: [
      {
        include: '$base'
      }
    ]
  }
  documentEnvironment: {
    comment: 'To stop the entire contents of the document environment being labelled. Its useless anyway, as I split up my work and just include it into the main file.'
    begin: '\\\\begin(\\{)(document)(\\})'
    beginCaptures:
      0:
        name: 'support.function.environment.begin.latex'
      1:
        name: 'punctuation.definition.argument.begin.latex'
      2:
        name: 'variable.parameter.argument.latex'
      3:
        name: 'punctuation.definition.argument.end.latex'
    end: '\\\\end(\\{)(document)(\\})'
    endCaptures:
      0:
        name: 'support.function.environment.end.latex'
      1:
        name: 'punctuation.definition.argument.begin.latex'
      2:
        name: 'variable.parameter.argument.latex'
      3:
        name: 'punctuation.definition.argument.end.latex'
    patterns: [
      {
        include: '$base'
      }
    ]
  }
  figureEnvironment: {
    comment: 'Matches the common figure environment'
    contentName: 'meta.environment.figure.latex'
    begin: '\\\\begin(\\{)(figure)(\\})((\\[)(\\w*)(\\]))?'
    beginCaptures:
      0:
        name: 'support.function.environment.begin.latex'
      1:
        name: 'punctuation.definition.argument.begin.latex'
      2:
        name: 'variable.parameter.argument.latex'
      3:
        name: 'punctuation.definition.argument.end.latex'
      5:
        name: 'punctuation.definition.optional.begin.latex'
      6:
        name: 'variable.parameter.optional.latex'
      7:
        name: 'punctuation.definition.optional.end.latex'
    end: '\\\\end(\\{)(\\2)(\\})'
    endCaptures:
      0:
        name: 'support.function.environment.end.latex'
      1:
        name: 'punctuation.definition.argument.begin.latex'
      2:
        name: 'variable.parameter.argument.latex'
      3:
        name: 'punctuation.definition.argument.end.latex'
    patterns: [
      {
        include: '$base'
      }
    ]
  }
  mathEnvironmentMeta: {
    comment: 'Matches math environments'
    patterns: [
      {
        include: '#alignMathEnvironment'
      }
    ]
  }
  alignMathEnvironment: {
    comment: 'Matches align environment'
    contentName: 'meta.environment.math.align.latex'
    begin: '\\\\begin(\\{)(align(\\*)?)(\\})'
    beginCaptures:
      0:
        name: 'support.function.environment.begin.latex'
      1:
        name: 'punctuation.definition.argument.begin.latex'
      2:
        name: 'variable.parameter.argument.latex'
      4:
        name: 'punctuation.definition.argument.end.latex'
    end: '\\\\end(\\{)(\\2)(\\})'
    endCaptures:
      0:
        name: 'support.function.environment.end.latex'
      1:
        name: 'punctuation.definition.argument.begin.latex'
      2:
        name: 'variable.parameter.argument.latex'
      3:
        name: 'punctuation.definition.argument.end.latex'
    patterns: [
      {
        include: '$base'
      }
    ]
  }
  listEnvironment: {
    comment: 'Matches itemize/enumerate/description environment'
    contentName: 'meta.environment.list.latex'
    begin: '\\\\begin(\\{)((itemize|enumerate|description)(\\*)?)(\\})'
    beginCaptures:
      0:
        name: 'support.function.environment.begin.latex'
      1:
        name: 'punctuation.definition.argument.begin.latex'
      2:
        name: 'variable.parameter.argument.latex'
      5:
        name: 'punctuation.definition.argument.end.latex'
    end: '\\\\end(\\{)(\\2)(\\})'
    endCaptures:
      0:
        name: 'support.function.environment.end.latex'
      1:
        name: 'punctuation.definition.argument.begin.latex'
      2:
        name: 'variable.parameter.argument.latex'
      3:
        name: 'punctuation.definition.argument.end.latex'
    patterns: [
      {
        include: '$base'
      }
    ]
  }
  makeatsomething: {
    comment: 'Matches the makeat(letter|other) commands so that they get custom highlighting (because @ is now a character)'
    contentName: 'markup.raw.verbatim.latex'
    begin: '(\\\\)makeatletter\\b'
    beginCaptures:
      0:
        name: 'support.function.makeat.latex'
    end: '(\\\\)makeatother\\b'
    endCaptures:
      0:
        name: 'support.function.makeat.latex'
    patterns: [
      {
        include: '#commentMeta'
      }
    ]
  }
  inputFile: {
    comment: 'Matches the input/include command and allows custom path colours.'
    begin: '\\\\input(?=[^a-zA-Z@])'
    beginCaptures:
      0:
        name: 'keyword.control.input.latex'
    end: '(?<=\\})|(^\\s*$)'
    endCaptures:
      1:
        name: 'invalid.illegal.latex'
    patterns:[
      {
        include: '#awaitingArgumentBrackets'
      }
      {
        comment: 'Only this one necessary because escaped characters will be picked up by awaitingArgumentBrackets.'
        include: '#lineComment'
      }
      {
        include: '#filePathScope'
      }
    ]
  }
  filePathScope: {
    comment: 'Matches a file path (UNIX only, add Windows yourself reader).'
    contentName: 'variable.parameter.argument.latex'
    begin: '\\{'
    beginCaptures:
      0:
        name: 'punctuation.definition.argument.begin.latex'
    end: '\\}'
    endCaptures:
      0:
        name: 'punctuation.definition.argument.end.latex'
    patterns: [
      {
        name: 'support.filepath.back.latex'
        match: '\\.{2}\\/'
      }
      {
        name: 'support.filepath.home.latex'
        match: '\\.\\/'
      }
      {
        name: 'support.filepath.root.latex'
        match: '(?<=\\{)\\/'
      }
      {
        name: 'support.filepath.directory.latex'
        match: '[^(\\.{1,2}\\/)].*?\\/'
      }
      {
        name: 'support.filepath.file.latex'
        match: '[^}]*'
      }
    ]
  }
  verbatim: {
    comment: 'Finds an inline verbatim string of the format \verb+...+'
    name: 'string.function.verbatim'
    match: '\\\\verb([^a-zA-Z])(.*?)(\\1)'
    captures:
      0:
        name: 'support.function.vebatim.latex'
      1:
        name: 'punctuation.latex'
      2:
        name: 'markup.raw.verbatim.latex'
      3:
        name: 'punctuation.latex'
  }
  item: {
    comment: 'This command is still defined everywhere'
    name: 'keyword.control.latex'
    match: '\\\\item'
  }

  # Unused
  unitMeasure: {
    comment: 'This will likely be merged into a different rule. Currently doesnt work.'
    name: 'constant.numeric.latex'
    match: '\\b((\\+|\\-)\\s*)?((\\d+(\\.|\\,)?)|(\\d*((\\.|\\,)\\d*)))\\s*(true\\s*)?(pt|pc|in|bp|cm|mm|dd|cc|sp|em|ex)\\b'
  }

  keywords: {
    comment: '''Taken from the TeXBook. Not sorted.
      at, bp, by, cc, cm, dd, depth, em, ex, fil, height, in, l, minus, mm, mu, pc, plus, pt, scaled, sp, spread, to, true, width
    '''
  }
  texPrimitives: {
    comment: 'This took a long time to write.'
    name: 'entity.name.function.primitive.latex'
    match: '(\\\\)(\\s|\\-|\\/|a(bove(displays(hortskip|kip)|withdelims)?|ccent|d(jdemerits|vance)|fter(assignment|group)|top(withdelims)?)|b(a(dness|selineskip|tchmode)|e(gingroup|lowdisplays(hortskip|kip))|inoppenalty|o(tmark|x(maxdepth)?)|rokenpenalty)|c(atcode|har(def)?|l(eaders|ose(in|out)|ubpenalty)|o(py|unt(def)?)|r(cr)?|sname)|d(ay|e(adcycles|f(ault(hyphenchar|skewchar))?|l(code|imiter(factor|shortfall)?))|i(men(def)?|s(cretionary|play(indent|limits|style|wid(owpenalty|th)))|vide)|oublehyphendemerits|p|ump)|e(def|lse|mergencystretch|nd(csname|group|input|linechar)?|qno|rr(help|message|or(contextlines|stopmode))|scapechar|very(cr|display|hbox|job|math|par|vbox)|x(hyphenpenalty|pandafter))|f(am|i(nalhyphendemerits|rstmark)?|loatingpenalty|ont(dimen|name)?|uturelet)|g(def|lobal(defs)?)|h(a(lign|ng(after|indent))|b(adness|ox)|f(il(l|neg)?|uzz)|o(ffset|ldinginserts)|rule|s(ize|kip|s)|t|yphen(ation|char|penalty))|i(f(ca(se|t)|dim|eof|false|h(box|mode)|inner|mmode|num|odd|true|v(box|mode|oid)|x)?|gnorespaces|mmediate|n(dent|put(lineno)?|sert(penalties)?|terlinepenalty))|jobname|kern|l(a(nguage|st(box|kern|penalty|skip))|ccode|e(aders|ft(hyphenmin|skip)?|qno|t)|i(mits|ne(penalty|skip(limit)?))|o(ng|oseness|wer(case)?))|m(a(g|rk|th(accent|bin|c(h(ar(def)?|oice)|lose|ode)|inner|o(p(en)?|rd)|punct|rel|surround)|xde(adcycles|pth))|e(aning|dmuskip|ssage)|kern|o(nth|ve(left|right))|skip|u(ltiply|skip(def)?))|n(ewlinechar|o(align|boundary|expand|indent|limits|ns(cript|topmode))|u(ll(delimiterspace|font)|mber))|o(mit|pen(in|out)|r|ut(er|put(penalty)?)|ver(fullrule|line|withdelims)?)|p(a(ge(depth|fil(l(lstretch|stretch)|stretch)|goal|s(hrink|tretch)|total)|r(fillskip|indent|s(hape|kip))?|tterns|using)|enalty|ostdisplaypenalty|re(display(penalty|size)|tolerance|v(depth|graf)))|r(a(dical|ise)|e(ad|l(ax|penalty))|ight(hyphenmin|skip)?|omannumeral)|s(cr(ipt(font|s(cript(font|style)|pace|tyle))|ollmode)|et(box|language)|fcode|h(ipout|ow(box(breadth|depth)?|lists|the)?)|k(ewchar|ip(def)?)|p(a(ce(factor|skip)|n)|ecial|lit(botmark|firstmark|maxdepth|topskip))|tring)|t(abskip|ext(font|style)|h(e|i(ckmuskip|nmuskip))|ime|o(ks(def)?|lerance|p(mark|skip))|racing(commands|lostchars|macros|o(nline|utput)|pa(ges|ragraphs)|restores|stats))|u(c(code|hyph)|n(derline|h(box|copy)|kern|penalty|skip|v(box|copy))|ppercase)|v(a(djust|lign)|b(adness|ox)|center|f(il(l|neg)?|uzz)|offset|rule|s(ize|kip|plit|s)|top)|w(d|idowpenalty|rite)|x(def|leaders|spaceskip)|year)(?=[^a-zA-Z])'
  }

  # Removed
  escapedPercent: {
    comment: 'Escaped % sign. Possible deprecated by escapedCharacter.'
    name: 'constant.character.latex'
    match: '\\\\%'
  }
  texKeywords: {
    comment: 'Official TeX keywords that can be used in certain situations. Done AFAIK.'
    name: 'support.constant.keyword.latex'
    match: '''(?x)
         at | by | bp | cc | cm | dd | depth | em | ex | fil | fill | filll | height | in | minus | mm | mu | pc | plus | pt | sp | spread | to | true | width
         '''
  }
