scopeName: 'source.latex'
name: 'LaTeX2e'
fileTypes: [
  'tex'
]

# Rules to be implemented. Please add to repository and link here to include.
patterns: [
    {
        comment: 'Always look for comments first so no bad matches happen.'
        include: '#commentMeta'
    }
    {
        include: '#usepackage'
    }
    {
        include: '#documentclass'
    }
    {
        comment: 'A catch all for any uncaught macro commands. Naturally, it needs to be last.'
        include: '#genericMacro'
    }
]

# List of available rules. Must 'include' a rule to patterns for it to be implemented.
repository:
    lineComment: {
        comment: 'Line comment. This will find an available % sign and match it and all that follows as a comment. Be sure to prevent edge cases like \\% or \\\% by only ever implementing in this order: doublebackslash -> escaped % -> %.'
        name: 'comment.line.percentage.latex'
        match: '''(?x)      # Allows regex breakdown like this
            %               # Is a percent sign
            .*              # And all that follows
        '''
    }
    escapedPercent: {
        comment: 'Escaped % sign.'
        name: 'constant.character.latex'
        match: '\\\\%'
    }
    escapedCurlyBracket: {
        comment: 'Escaped }.'
        name: 'constant.character.latex'
        match: '\\\\}|\\\\{'
    }
    usepackage: {
        comment: 'Package finder. Similar to documentclass, but allows custom colours. A macro name is only valid with letters (exceptions apply--eg. makeatletter). This checks to see if the name is purely "usepackage" and the following character is not a legal part of the macro name.'
        begin: '(\\\\)usepackage(?=[^a-zA-Z@])'
        beginCaptures:
            0:
                name: 'keyword.control.preamble.latex'
            1:
                name: 'punctuation.definition.function.latex'
        end: '(?<=\\})|(^\\s*$)'
        endCaptures:
            1:
                name: 'invalid.illegal.latex'
        patterns:[
            {
                include: '#awaitingArgumentBrackets'
            }
            {
                comment: 'Only this one necessary because escaped characters will be picked up by awaitingArgumentBrackets.'
                include: '#lineComment'
            }
            {
                comment: 'Will try and find optional arguments first.'
                include: '#optionalArgumentScope'
            }
            {
                include: '#argumentScope'
            }
        ]
    }
    doubleBackslash: {
        match: '\\\\\\\\'
        name: 'punctuation.break.latex'
    }
    commentMeta: {
        comment: 'Main purpose is to distinguish escaped % from comments.'
        patterns: [
            {
                include: '#doubleBackslash'
            }
            {
                include: '#escapedPercent'
            }
            {
                include: '#magicComment'
            }
            {
                include: '#lineComment'
            }
        ]
    }
    genericMacro: {
        comment: 'A catch all for latex macros that have not already been identified.'
        name: 'support.function.general.latex'
        match: '\\\\[a-zA-Z]+'
    }
    magicComment: {
        comment: 'Magic commands work in first 20 lines. Can be improved to change color depending if the command matches a known string'
        name: 'keyword.control.magic.latex'
        match: '''(?x)    # Allow comments like this
            ((              # Capture groups 1 & 2
                (%)         # Capture percent sign
                (\\ !(?>TEX|BIB)\\ )    # Exact match required
                (\\S+)      # A word (this is required as far as I know)
                )           # End capture group 2
                (\\ = \\ )  # Match = with space (required)
            )               # End capture group 1
            (\\S+)(\\s*)$   # Any non whitespace then only wspace to end
        '''
    }
    documentclass: {
        comment: 'Documentclass finder.'
        begin: '(\\\\)documentclass(?=[^a-zA-Z@])'
        beginCaptures:
            0:
                name: 'keyword.control.preamble.latex'
            1:
                name: 'punctuation.definition.function.latex'
        end: '(?<=\\})|(^\\s*$)'
        endCaptures:
            1:
                name: 'invalid.illegal.latex'
        patterns:[
            {
                include: '#awaitingArgumentBrackets'
            }
            {
                include: '#lineComment'
            }
            {
                include: '#optionalArgumentScope'
            }
            {
                include: '#nestedCurlyBrackets'
            }
        ]
    }
    awaitingArgumentBrackets: {
        comment: 'Anything not whitespace, opening bracket or comment will be flagged as invalid.illegal. Should take priority over other matches (even comments, as comments have the escaped % exception).'
        match: '[^{\\[\\s%]+'
        name: 'invalid.illegal.latex'
    }
    optionalArgumentScope: {
        comment: 'Matches options brackets and everything inside them.'
        contentName: 'variable.parameter.optional.latex'
        begin: '\\['
        beginCaptures:
            0:
                name: 'punctuation.definition.optional.begin.latex'
        end: '\\]'
        endCaptures:
            0:
                name: 'punctuation.definition.optional.end.latex'
        patterns: [
            {
                comment: 'AFAIK, the optional parameters never have nested brackets. Will come back to this after a while or if I find they do.'
                include: '#commentMeta'
            }
            {
                include: '#escapedCurlyBracket'
            }
            {
                include: '#nestedCurlyBrackets'
            }
        ]
    }
    argumentScope: {
        comment: 'Matches arguments brackets (the outmost of nested brackets)'
        contentName: 'variable.parameter.argument.latex'
        begin: '\\{'
        beginCaptures:
            0:
                name: 'punctuation.definition.argument.begin.latex'
        end: '\\}'
        endCaptures:
            0:
                name: 'punctuation.definition.argument.end.latex'
        patterns: [
            {
                include: '#commentMeta'
            }
            {
                include: '#escapedCurlyBracket'
            }
            {
                include: '#nestedCurlyBrackets'
            }
        ]
    }
    nestedCurlyBrackets: {
        contentName: 'variable.parameter.argument.latex'
        begin: '{'
        beginCaptures:
            0:
                name: 'punctuation.definition.argument.latex'
        end: '}'
        endCaptures:
            0:
                name: 'punctuation.definition.argument.latex'
        patterns: [
            comment: 'Optimisation good to implement here. Rework commentMeta to be a more general check for escaped characters and comments'
            {
                include: '#commentMeta'
            }
            {
                include: '#escapedCurlyBracket'
            }
            {
                include: '#nestedCurlyBrackets'
            }
        ]
    }
    # nestedSquareBrackets: {
    #     contentName: 'variable.parameter.optional.latex'
    #     begin: '\\['
    #     beginCaptures:
    #         0:
    #             name: 'punctuation.definition.optional.begin.latex'
    #     end: '\\]'
    #     endCaptures:
    #         0:
    #             name: 'punctuation.definition.optional.end.latex'
    #     patterns: [
    #         comment: 'Optimisation good to implement here. Rework commentMeta to be a more general check for escaped characters and comments'
    #         {
    #             include: '#commentMeta'
    #         }
    #         {
    #             include: '#escapedCloseSquareBracket'
    #         }
    #         {
    #             include: '#nestedSquareBrackets'
    #         }
    #     ]
    # }
    endArgumentsMeta: {
        patterns: [
            {
                include: '#doubleBackslash'
            }
            {
                include: '#escapedCurlyBracket'
            }
        ]
    }
    texKeywords: {
        comment: 'Official TeX keywords that can be used in certain situations. Done AFAIK.'
        name: 'support.constant.keyword.latex'
        match: '''(?x)
        at | by | bp | cc | cm | dd | depth | em | ex | fil | fill | filll | height | in | minus | mm | mu | pc | plus | pt | sp | spread | to | true | width
        '''
    }
    texPrimitives: {
        comment: 'Primitives (no smaller definitions) can be confirmed using \show\<cm>. This list is obviously not finished.'
        match: '''(?x)
        (\\\\)(
        above | badness | relax | show
        )
        '''
    }
