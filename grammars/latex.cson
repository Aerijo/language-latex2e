scopeName: 'text.tex.latex'
name: 'LaTeX2e'
fileTypes: [ 'tex' ]
limitLineLength: false

# Atom uses the following regex engine -> https://github.com/kkos/oniguruma/blob/master/doc/RE

# Rules to be implemented. Please add to repository and link to a 'meta' to include.
# The following rules correspond to the ten special latex characters. They are applied at the outmost level, but can be called inside patterns by using `$self`
patterns: [
  { include: '#metaControl' } # must go first to catch escaped sequences
  { include: '#metaPercent' }
  { include: '#metaDollar' }
  { include: '#metaTilde' }
  { include: '#metaAmpersand' }
  { include: '#metaOpenBrace' }
  { include: '#metaCloseBrace' }
  { include: '#metaUnderscore' }
  { include: '#metaCaret' }
  { include: '#metaHashtag' }
]

repository:
# Main meta groups; directly referenced in `patterns`
  metaControl: {
    comment: 'All these commands begin with a backslash.'
    patterns: [
      { include: '#metaCommonControlSequences' }
      { include: '#metaEnvironment' }
      { include: '#metaDollar' } # Because of \( and \[. Must appear below escaped characters, to prevent \$ from being a false positive.

      # The following rules are "catch alls" for any control sequences not explicitly addressed above.
      { include: '#metaPrimitives' }
      { include: '#controlSymbol' }
      { include: '#controlWord' }
    ]
  }
  metaPercent: {
    comment: 'This is called when there is a lone percent sign (escaped covered by metaControl).'
    patterns: [
      { include: '#magicComment' }
      { include: '#lineComment' }
    ]
  }
  metaDollar: {
    comment: 'Called when $ sign found. Posiibly deprecated by \( and \) (which is called in metaControl), but here for completeness. The previous statement did not make its meaning very clear.'
    patterns: [
      { include: '#displayMathMode' }
      { include: '#inlineMathMode' }
    ]
  }
  metaTilde: {
    comment: 'This is only an unbreaking space (when alone).'
    name: 'punctuation.space.latex'
    match: '~'
  }
  metaAmpersand: {
    comment: 'The ampersand normally represents alignment (catcode 4). Probably not useful (or legal) outside of align or table environment. However, it must be left this way to let users implement custom environments.'
    name: 'punctuation.alignment.latex'
    match: '&'
  }
  metaOpenBrace: {
    comment: 'This is useful to ensure balanced brackets for things like {$ math {nested math} math $}, as `}` ends mathmode (for other reasons).'
    contentName: 'meta.group.braces.latex'
    begin: '{'
    beginCaptures:
      0:
        name: 'punctuation.definition.group.begin.latex'
    end: '}'
    endCaptures:
      0:
        name: 'punctuation.definition.group.end.latex'
    patterns: [
      { include: '$self' }
    ]
  }
  metaCloseBrace: {
    comment: 'To reach this means unbalanced brackets: THIS IS AN ERROR. I dont care if youre doing fancy file mish-mashing; DONT DO IT. The capture groups feels like a hack job to get multiple scopes on the same match, but oh well.'
    captures:
      0:
        name: 'invalid.illegal.latex'
      1:
        name: 'punctuation.definition.group.end.latex'
    match: '(})'
  }
  metaUnderscore: {
    comment: 'Underscore means subscript. It will take an argument in brackets if possible. If not, just the single next character. Only valid when within mathmode. May address this later.'
    name: 'markup.other.subscript.latex'
    begin: '(\\_)\\s*'
    beginCaptures:
      1:
        name: 'punctuation.subscript.latex'
    end: '(?<=[^\\_\\s])'
    patterns: [
      { include: '$self' }
    ]
  }
  metaCaret: {
    comment: 'Like underscore, but superscript'
    patterns: [
      { include: '#doubleCaret' }
      {
        comment: 'Matches a caret and following group'
        name: 'markup.other.superscript.latex'
        begin: '(\\^)\\s*'
        beginCaptures:
          1:
            name: 'punctuation.superscript.latex'
        end: '(?<=[^\\^\\s])'
        patterns: [
          { include: '$self' }
        ]
      }
    ]
  }
  metaHashtag: {
    comment: 'I dont like calling this the pound symbol. Catcode says it is a parameter identifier.'
    match: '(\\#{3,}[0-9]+)|(\\#{2}[0-9]+)|(\\#[0-9]+)'
    captures:
      1:
        name: 'variable.parameter.hashtag.3.latex'
      2:
        name: 'variable.parameter.hashtag.2.latex'
      3:
        name: 'variable.parameter.hashtag.1.latex'
  }

# Other meta groups
  metaCommonControlSequences: {
    comment: 'This is a collection of control sequences that are given specific rules. The ones here should be common to all users.'
    patterns: [
      { include: '#doubleBackslash' }
      { include: '#escapedCharacter' }
      { include: '#documentclass' }
      { include: '#usepackage' }
      { include: '#inputFile' }
      { include: '#sectioning' }
      { include: '#makeAtSomething' }
      { include: '#verbatim' }
      { include: '#item' }
      { include: '#metaHyperref' }
      { include: '#text' } # Seems to work well!
      { include: '#metaFontStyling' } # eg. \emph
      { include: '#metaFootnote' }
      { include: '#metaReferences' } # maybe include \ref \label as well?
      { include: '#constants' } # words that represent constants

      # Potential additions:
      # { include: '#commandDefinitions' }
      # { include: '#marginpar' }
      # { include: '#verbScantokens' } # not sure what this is for
    ]
  }
  metaEnvironment: {
    comment: 'This collection can be used to give properties to specific environments.'
    patterns: [
      { include: '#envDocument' }
      { include: '#envFigure' }
      { include: '#metaEnvMath' }
      # { include: '#metaEnvTable' }
      { include: '#envList' }
      # { include: '#envGnuplot' }
      # { include: '#metaEnvMinted' }
      # { include: '#metaEnvListing' }
      # { include: '#envLuaCode' }
      { include: '#envVerbatim' }
      # { include: '#tikzPicture' }
      { include: '#envGeneric' }
    ]
  }
  metaPrimitives: {
    comment: 'Allows organisation of various primitive sources'
    patterns: [
      { include: '#texPrimitives' }
      { include: '#pdfTexPrimitives' }
      { include: '#unsortedPrimitives' }
    ]
  }
  metaFontStyling: {
    comment: 'For commands that apply bold/italic/emph to text. The first ones are for LaTeX, the latter are plain TeX (deprecated)'
    patterns: [
      {
        begin: '((\\\\)textbf)\\s*(\\{)'
        beginCaptures:
          1:
            name: 'support.function.textbf.latex'
          2:
            name: 'punctuation.definition.function.latex'
          3:
            name: 'punctuation.definition.arguments.begin.latex'
        end: '\\}'
        endCaptures:
          0:
            name: 'punctuation.definition.arguments.end.latex'
        contentName: 'markup.bold.latex'
        patterns: [
          {include: '$self'}
        ]
      }
      {
        begin: '((\\\\)textit)\\s*(\\{)'
        beginCaptures:
          1:
            name: 'support.function.textit.latex'
          2:
            name: 'punctuation.definition.function.latex'
          3:
            name: 'punctuation.definition.arguments.begin.latex'
        end: '\\}'
        endCaptures:
          0:
            name: 'punctuation.definition.arguments.end.latex'
        contentName: 'markup.italic.latex'
        patterns: [
          {include: '$self'}
        ]
      }
      {
        begin: '((\\\\)texttt)\\s*(\\{)'
        beginCaptures:
          1:
            name: 'support.function.texttt.latex'
          2:
            name: 'punctuation.definition.function.latex'
          3:
            name: 'punctuation.definition.arguments.begin.latex'
        end: '\\}'
        endCaptures:
          0:
            name: 'punctuation.definition.arguments.end.latex'
        contentName: 'markup.raw.texttt.latex'
        patterns: [
          {include: '$self'}
        ]
      }
      {
        begin: '((\\\\)emph)\\s*(\\{)'
        beginCaptures:
          1:
            name: 'support.function.emph.latex'
          2:
            name: 'punctuation.definition.function.latex'
          3:
            name: 'punctuation.definition.arguments.begin.latex'
        end: '\\}'
        endCaptures:
          0:
            name: 'punctuation.definition.arguments.end.latex'
        contentName: 'markup.italic.emph.latex'
        patterns: [
          {include: '$self'}
        ]
      }
      {
        comment: 'plain TeX; deprecated'
        match: '((\\\\)(?:bf|it|rm|sc|sf|sl|tt))(?=[^a-zA-Z@])'
        captures:
          1:
            name: 'invalid.deprecated.font.latex'
          2:
            name: 'punctuation.definition.function.latex'
      }
    ]
  }
  metaHyperref: {
    comment: 'Intended to match the url commands provided by hyperref. Less lenient than I would like, but difficult to improve.'
    patterns: [
      {
        comment: '\\href[options]{URL}{text}'
        begin: '((\\\\)href)\\s*(?:(\\[)(.*?)(\\]))?\\s*(\\{)(.*?)(\\})(\\{)'
        beginCaptures:
          1:
            name: 'support.function.href.latex'
          2:
            name: 'punctuation.definition.function.latex'
          3:
            name: 'punctuation.definition.arguments.optional.begin.latex'
          4:
            name: 'variable.parameter.optional.latex'
          5:
            name: 'punctuation.definition.arguments.optional.end.latex'
          6:
            name: 'punctuation.definition.arguments.begin.latex'
          7:
            name: 'markup.underline.link.latex'
          8:
            name: 'punctuation.definition.arguments.end.latex'
          9:
            name: 'punctuation.definition.arguments.begin.latex'
        end: '(\\}|^\\s*$)'
        endCaptures:
          0:
            name: 'punctuation.definition.arguments.end.latex'
        contentName: 'variable.parameter.latex'
        patterns: [
          { include: '$self' }
        ]
      }
      {
        comment: '\\url{URL}'
        match: '((\\\\)(?:nolink|hyperbase)url)(\\{)(.*?)(\\})'
        captures:
          1:
            name: 'support.function.url.latex'
          2:
            name: 'punctuation.definition.function.latex'
          3:
            name: 'punctuation.definition.arguments.begin.latex'
          4:
            name: 'markup.underline.link.latex'
          5:
            name: 'punctuation.definition.arguments.end.latex'
      }
      {
        comment: '\\hyperimage{URL}{text}'
        begin: '((\\\\)hyperimage)(\\{)(.*?)(\\})(\\{)'
        beginCaptures:
          1:
            name: 'support.function.url.image.latex'
          2:
            name: 'punctuation.definition.function.latex'
          3:
            name: 'punctuation.definition.arguments.begin.latex'
          4:
            name: 'markup.underline.link.latex'
          5:
            name: 'punctuation.definition.arguments.end.latex'
          6:
            name: 'punctuation.definition.arguments.begin.latex'
        end: '(\\}|^\\s*$)'
        endCaptures:
          0:
            name: 'punctuation.definition.arguments.end.latex'
        contentName: 'variable.parameter.latex'
        patterns: [
          { include: '$self' }
        ]
      }
      # {
      #   comment: '\hyperdef{category}{name}{text}'
      # }
      {
        comment: '\\hyperref{URL}{category}{name}{text}; will only attempt to match the URL part.'
        match: '((\\\\)hyperref)(\\{)(.*?)(\\})'
        captures:
          1:
            name: 'support.function.url.latex'
          2:
            name: 'punctuation.definition.function.latex'
          3:
            name: 'punctuation.definition.arguments.begin.latex'
          4:
            name: 'markup.underline.link.latex'
          5:
            name: 'punctuation.definition.arguments.end.latex'
      }
    ]
  }
  metaFootnote: {
    patterns: [
      {
        match: '(\\\\)footnotemark(?![a-zA-Z@])'
        captures:
          0:
            name: 'support.function.footnote.footnotemark.latex'
          1:
            name: 'punctuation.definition.function.latex'
      }
      {
        begin: '((\\\\)footnote(?:text)?)\\s*(\\{)'
        beginCaptures:
          1:
            name: 'support.function.footnote.latex'
          2:
            name: 'punctuation.definition.function.latex'
          3:
            name: 'punctuation.definition.arguments.begin.latex'
        end: '\\}'
        endCaptures:
          0:
            name: 'punctuation.definition.arguments.end.latex'
        contentName: 'meta.footnote.latex'
        patterns: [{ include: '$self' }]
      }
    ]
  }
  metaReferences: {
    comment: 'The following have all been taken (mostly) directly from language-latex.'
    patterns: [
      {
        comment: 'Taken from language-latex'
        begin: '((\\\\)(?:\\w*[rR]ef\\*?))(\\{)'
        beginCaptures:
          1:
            name: 'keyword.control.ref.latex'
          2:
            name: 'punctuation.definition.keyword.latex'
          3:
            name: 'punctuation.definition.arguments.begin.latex'
        end: '\\}'
        endCaptures:
          0:
            name: 'punctuation.definition.arguments.begin.latex'
        contentName: 'meta.reference.latex'
        patterns: [
          { include: '#controlWord' }
          { include: '#controlSymbol' }
          {
            match: '[!\u0028-\u007A\u00A1-\u017F\u3001-\u30FF\u0391-\u03CE\u0410-\u044F\u4E00-\u9FFF\uFF0C\uFF0E]'
            name: 'constant.other.reference.latex'
          }
        ]
      }
      {
        comment: 'Taken from language-latex'
        begin: '((\\\\)label)(\\{)'
        beginCaptures:
          1:
            name: 'keyword.control.label.latex'
          2:
            name: 'punctuation.definition.keyword.latex'
          3:
            name: 'punctuation.definition.arguments.begin.latex'
        end: '\\}'
        endCaptures:
          0:
            name: 'punctuation.definition.arguments.end.latex'
        name: 'meta.definition.latex'
        patterns: [
          { include: '#controlWord' }
          { include: '#controlSymbol' }
          {
            match: '[!\u0028-\u007A\u00A1-\u017F\u3001-\u30FF\u0391-\u03CE\u0410-\u044F\u4E00-\u9FFF\uFF0C\uFF0E]'
            name: 'constant.other.reference.latex'
          }
        ]
      }
      {
        comment: 'Taken from language-latex'
        begin: '''(?x)
                    ((\\\\)(?:text)?(?:paren)?(?:auto)?(?:foot)?(?:full)?(?:no)?(?:short)?[cC]ites?(?:al)?(?:t|p|author|year(?:par)?|title)?[ANP]*\\*?)
                    (?:(\\[)[^\\]]*(\\]))?
                    (?:(\\[)[^\\]]*(\\]))?
                    (\\{)
                 '''
        captures:
          1:
            name: 'keyword.control.cite.latex'
          2:
            name: 'punctuation.definition.keyword.latex'
          3:
            name: 'punctuation.definition.arguments.optional.begin.latex'
          4:
            name: 'punctuation.definition.arguments.optional.end.latex'
          5:
            name: 'punctuation.definition.arguments.optional.begin.latex'
          6:
            name: 'punctuation.definition.arguments.optional.end.latex'
          7:
            name: 'punctuation.definition.arguments.latex'
        end: '\\}'
        endCaptures:
          0:
            name: 'punctuation.definition.arguments.latex'
        name: 'meta.citation.latex'
        patterns: [
          { include: '#controlWord' }
          { include: '#controlSymbol' }
          {
            match: '[!\u0028-\u007A\u00A1-\u017F\u3001-\u30FF\u0391-\u03CE\u0410-\u044F\u4E00-\u9FFF\uFF0C\uFF0E]'
            name: 'constant.other.reference.citation.latex'
          }
        ]
      }
      {
        comment: 'Taken from language-latex'
        begin: '(\\\\bibitem)(\\{)'
        beginCaptures:
          1:
            name: 'keyword.control.bibitem.latex'
          2:
            name: 'punctuation.definition.arguments.begin.latex'
        end: '\\}'
        endCaptures:
          0:
            name: 'punctuation.definition.arguments.end.latex'
        patterns: [
          { include: '#controlWord' }
          { include: '#controlSymbol' }
          {
            match: '[!\u0028-\u007A\u00A1-\u017F\u3001-\u30FF\u0391-\u03CE\u0410-\u044F\u4E00-\u9FFF\uFF0C\uFF0E]'
            name: 'constant.other.reference.bibitem.latex'
          }
        ]
      }
    ]
  }

# Other
  escapedCharacter: {
    comment: 'Finds escaped characters like \$ and \%. Uses this regex so unique capture groups can be used.'
    name: 'constant.character.latex'
    match: '\\\\(\\&|\\%|\\$|\\#|\\_|\\{|\\}|(textascii(tilde|circum)|textbackslash)(?=[^a-zA-Z@]))'
  }
  controlSymbol: {
    comment: 'Mostly covered by escapedCharacter, but this is a catch all for any control symbols'
    name: 'keyword.control.symbol.$1.latex'
    match: '\\\\([^a-zA-Z@]|@[^a-zA-A@])'
  }
  controlWord: {
    comment: 'A catch all for latex control words that have not already been identified.'
    name: 'support.function.general.$1.latex'
    match: '\\\\([a-zA-Z@]+)'
  }
  accents: {
    comment: 'For standard latex accent macros such as \^ or \`. Not used for now, at least until better rules are developed.'
    name: 'constant.character.accent.latex'
    match: '''\\\\([\\`\\'\\^\\"\\~\\=\\.]\\s*(\\w|\\{\\w?\\})|[Hcklbdruv]\\{\\w?\\})'''
  }
  lineComment: {
    name: 'comment.line.percentage.latex'
    begin: '%'
    end: '$'
    patterns: [
      { include: '#magicComment' }
    ]
  }
  escapedCurlyBracket: {
    comment: 'Escaped }. Possible deprecated by escapedCharacter.'
    name: 'constant.character.latex'
    match: '\\\\}|\\\\{'
  }
  usepackage: {
    comment: 'Package finder. Similar to documentclass, but allows custom colours. A macro name is only valid with letters (exceptions apply--eg. makeatletter). This checks to see if the name is purely "usepackage" and the following character is not a legal part of the macro name.'
    name: 'meta.preamble.latex'
    begin: '\\\\usepackage(?=[^a-zA-Z@])'
    beginCaptures:
      0:
        name: 'keyword.control.preamble.latex'
    end: '(?<=\\})|(^\\s*$)'
    endCaptures:
      1:
        name: 'invalid.illegal.latex'
    patterns:[
      { include: '#awaitingArgumentBrackets' }
      {
        comment: 'Only this one necessary because escaped characters will be picked up by awaitingArgumentBrackets.'
        include: '#lineComment'
      }
      {
        comment: 'Will try and find optional arguments first.'
        include: '#optionalArgumentScope'
      }
      { include: '#altArgumentScope' }
    ]
  }
  sectioning: {
    comment: 'Covers all sectioning commands such as section, subsection, subparagraph, etc. The last four are KOMAscript specific.'
    name: 'support.function.section.latex'
    begin: '\\\\((sub){0,2}section|(sub){0,1}paragraph|part|chapter|addpart|addchap|addsec|minisec)(\\*)?(?=[^a-zA-Z@])'
    beginCaptures:
      0:
        name: 'entity.name.section.$1.latex'
    end: '(?<=\\})|(^\\s*$)'
    endCaptures:
      1:
        name: 'invalid.illegal.latex'
    patterns: [
      { include: '#awaitingArgumentBrackets' }
      {
        comment: 'Only this one necessary because escaped characters will be picked up by awaitingArgumentBrackets.'
        include: '#lineComment'
      }
      {
        comment: 'Will try and find optional arguments first.'
        include: '#optionalArgumentScope'
      }
      { include: '#argumentScope' }
    ]
  }
  doubleBackslash: {
    match: '\\\\\\\\'
    name: 'constant.character.newline.latex'
  }
  commentMeta: {
    comment: 'Main purpose is to distinguish escaped % from comments. Deprecated.'
    patterns: [
      { include: '#doubleBackslash' }
      { include: '#escapedCharacter' }
      { include: '#magicComment' }
      { include: '#lineComment' }
    ]
  }
  magicComment: {
    comment: 'Can be improved to change color depending if the command matches a known string'
    name: 'keyword.control.magic.latex'
    match: '''(?x)   # Allow comments like this. More of an educational thing, really, for anyone reading this.
     ((        # Capture groups 1 & 2
       (%)     # Capture percent sign
       (\\ !(?>TEX|BIB)\\ )  # See https://github.com/kkos/oniguruma/blob/771535fce64f225f9fa2f965dbb55277e18fbde9/doc/RE#L252 for ?>
       (\\S+)    # A word (this is required as far as I know)
       )       # End capture group 2
       (\\ = \\ )  # Match = with space (required)
     )         # End capture group 1
     .*$       # To end; some options have spaces
   '''
  }
  documentclass: {
    comment: 'Documentclass finder.'
    name: 'meta.preamble.latex'
    begin: '\\\\documentclass(?=[^a-zA-Z@])'
    beginCaptures:
      0:
        name: 'keyword.control.preamble.latex'
    end: '(?<=\\})|(^\\s*$)'
    endCaptures:
      1:
        name: 'invalid.illegal.latex'
    patterns:[
      { include: '#awaitingArgumentBrackets' }
      { include: '#lineComment' }
      { include: '#optionalArgumentScope' }
      { include: '#altArgumentScope' }
    ]
  }
  awaitingArgumentBrackets: {
    comment: 'Anything not whitespace, opening bracket or comment will be flagged as invalid.illegal. Should take priority over other matches (even comments, as comments have the escaped % exception).'
    match: '[^{\\[\\s%]+'
    name: 'invalid.illegal.latex'
  }
  optionalArgumentScope: {
    comment: 'Matches options brackets and everything inside them.'
    contentName: 'variable.parameter.optional.latex'
    begin: '\\['
    beginCaptures:
      0:
        name: 'punctuation.definition.optional.begin.latex'
    end: '\\]'
    endCaptures:
      0:
        name: 'punctuation.definition.optional.end.latex'
    patterns: [
      {
        comment: 'AFAIK, the optional parameters never have nested brackets. Will come back to this after a while or if I find they do.'
        include: '#commentMeta'
      }
      { include: '#escapedCurlyBracket' }
      { include: '#metaOpenBrace' }
    ]
  }
  argumentScope: {
    comment: 'Matches arguments brackets (the outmost of nested brackets). Is a general rule to use anywhere.'
    contentName: 'variable.parameter.arguments.latex'
    begin: '\\{'
    beginCaptures:
      0:
        name: 'punctuation.definition.arguments.begin.latex'
    end: '\\}'
    endCaptures:
      0:
        name: 'punctuation.definition.arguments.end.latex'
    patterns: [
      { include: '$self' }
    ]
  }
  altArgumentScope: {
    comment: 'Matches arguments brackets (the outmost of nested brackets). Specifically for commands like usepackage.'
    contentName: 'support.class.latex'
    begin: '\\{'
    beginCaptures:
      0:
        name: 'punctuation.definition.arguments.begin.latex'
    end: '\\}'
    endCaptures:
      0:
        name: 'punctuation.definition.arguments.end.latex'
    patterns: [
      { include: '$self' }
    ]
  }
  nestedSquareBrackets: {
    contentName: 'variable.parameter.optional.latex'
    begin: '\\['
    beginCaptures:
      0:
        name: 'punctuation.definition.optional.begin.latex'
    end: '\\]'
    endCaptures:
      0:
        name: 'punctuation.definition.optional.end.latex'
    patterns: [
      comment: 'Optimisation good to implement here. Rework commentMeta to be a more general check for escaped characters and comments'
      { include: '#commentMeta' }
      { include: '#escapedCloseSquareBracket' }
      { include: '#nestedSquareBrackets' }
    ]
  }
  inlineMathMode: {
    comment: 'This can be triggered using $ or \( \). Both can be used in the same pair.'
    contentName: 'string.other.math.inline.latex'
    begin: '(\\$)|(\\\\\\()'
    beginCaptures:
      0:
        name: 'string.other.math.inline.begin.latex'
    end: '(\\$)|(\\\\\\))|(?=\\})'
    endCaptures:
      0:
        name: 'string.other.math.inline.end.latex'
    patterns: [
      {
        comment: 'When in inline math, the exit can only be $ or \)'
        name: 'invalid.illegal.latex'
        match: '(\\\\(\\[|\\(|\\)))'
      }
      { include: '$self' }
    ]
  }
  displayMathMode: {
    comment: 'This can be triggered using $$ or \[ \]. Both can be used in the same pair.'
    contentName: 'string.other.math.display.latex'
    begin: '(\\$\\$)|(\\\\\\[)'
    beginCaptures:
      0:
        name: 'string.other.math.display.begin.latex'
      1:
        name: 'invalid.deprecated.latex'
    end: '(\\$\\$)|(\\\\\\])|(?=\\})'
    endCaptures:
      0:
        name: 'string.other.math.display.end.latex'
      1:
        name: 'invalid.deprecated.latex'
    patterns: [
      {
        comment: 'When in display math, the exit can only be $$ or \]'
        name: 'invalid.illegal.latex'
        match: '(?<=[^\\\\])(\\$)(?=[^\\$])|(\\\\(\\[|\\(|\\)))'
      }
      { include: '$self' }
    ]
  }
  makeAtSomething: {
    comment: 'Matches the makeat(letter|other) commands so that they get custom highlighting (because @ is now a character)'
    contentName: 'markup.raw.verbatim.latex' # To make user aware of its effect
    begin: '(\\\\)makeatletter\\b'
    beginCaptures:
      0:
        name: 'support.function.makeat.latex'
    end: '(\\\\)makeatother\\b'
    endCaptures:
      0:
        name: 'support.function.makeat.latex'
    patterns: [
      { include: '$self'}
    ]
  }
  inputFile: {
    comment: 'Matches the input/include command and allows custom path colours. Technically a single letter file is valid, but I think it unlikely someone legitimately means it.'
    begin: '\\\\(input|include)(?=[^a-zA-Z@])'
    beginCaptures:
      0:
        name: 'keyword.control.$1.latex'
    end: '(?<=\\})|(^\\s*$)'
    endCaptures:
      1:
        name: 'invalid.illegal.latex'
    patterns:[
      { include: '#awaitingArgumentBrackets' }
      {
        comment: 'Only this one necessary because escaped characters will be picked up by awaitingArgumentBrackets.'
        include: '#lineComment'
      }
      { include: '#filePathScope' }
    ]
  }
  filePathScope: {
    comment: 'Matches a file path (UNIX only, add Windows yourself reader).'
    contentName: 'variable.parameter.arguments.latex'
    begin: '\\{'
    beginCaptures:
      0:
        name: 'punctuation.definition.arguments.begin.latex'
    end: '\\}'
    endCaptures:
      0:
        name: 'punctuation.definition.arguments.end.latex'
    patterns: [
      {
        name: 'support.filepath.back.latex'
        match: '\\.{2,}\\/'
      }
      {
        name: 'support.filepath.home.latex'
        match: '\\.\\/'
      }
      {
        name: 'support.filepath.root.latex'
        match: '(?<=\\{)\\/'
      }
      {
        name: 'support.filepath.directory.latex'
        match: '[^(\\.+\\/)].*?\\/'
      }
      {
        name: 'support.filepath.file.latex'
        match: '[^}]*'
      }
    ]
  }
  verbatim: {
    comment: 'Finds an inline verbatim string of the format \verb+...+'
    name: 'string.function.verbatim'
    match: '\\\\verb([^a-zA-Z])(.*?)(\\1)'
    captures:
      0:
        name: 'support.function.vebatim.latex'
      1:
        name: 'punctuation.latex'
      2:
        name: 'markup.raw.verbatim.latex'
      3:
        name: 'punctuation.latex'
  }
  item: {
    comment: 'This command is still defined everywhere'
    name: 'keyword.control.latex'
    match: '\\\\item(?![a-zA-Z@])'
  }

  # Environments
  envGeneric: {
    comment: 'Matches environments not recognised by other rules. Less lenient with random formatting here, it is expected to all be on one line.'
    contentName: 'meta.environment.general.$5.latex'
    begin: '((\\\\)begin)(\\{)((\\w+)\\*?)(\\})(?:(\\[)(.*?)(\\]))?'
    beginCaptures:
      1:
        name: 'support.function.environment.begin.latex'
      2:
        name: 'punctuation.definition.function.begin.latex'
      3:
        name: 'punctuation.definition.arguments.begin.latex'
      4:
        name: 'variable.parameter.environment.$5.latex'
      # 5: Used for meta scope name (basically just non starred version)
      6:
        name: 'punctuation.definition.arguments.end.latex'
      7:
        name: 'punctuation.definition.arguments.optional.begin.latex'
      8:
        name: 'variable.parameter.optional.function.environment.latex'
      9:
        name: 'punctuation.definition.arguments.optional.end.latex'
    end: '((\\\\)end)(\\{)(\\4)(\\})'
    endCaptures:
      1:
        name: 'support.function.environment.end.latex'
      2:
        name: 'punctuation.definition.function.latex'
      3:
        name: 'punctuation.definition.arguments.begin.latex'
      4:
        name: 'variable.parameter.environment.latex'
      5:
        name: 'punctuation.definition.arguments.end.latex'
    patterns: [{ include: '$self' }]
  }
  envDocument: {
    comment: 'To stop the entire contents of the document environment being labelled. Its useless anyway, as I split up my work and just include it into the main file.'
    match: '((\\\\)(begin|end))(\\{)(document)(\\})'
    captures:
      1:
        name: 'support.function.environment.$3.document.latex'
      2:
        name: 'punctuation.definition.function.latex'
      # 3: This is for the first group scopes
      4:
        name: 'punctuation.definition.arguments.begin.latex'
      5:
        name: 'variable.parameter.environment.document.latex'
      6:
        name: 'punctuation.definition.arguments.end.latex'
  }
  envFigure: {
    comment: 'Matches the common figure environment'
    contentName: 'meta.environment.float.$5.latex'
    begin: '((\\\\)begin)(\\{)((figure)\\*?)(\\})(?:(\\[)(.*?)(\\]))?'
    beginCaptures:
      1:
        name: 'support.function.environment.begin.latex'
      2:
        name: 'punctuation.definition.function.begin.latex'
      3:
        name: 'punctuation.definition.arguments.begin.latex'
      4:
        name: 'variable.parameter.environment.$5.latex'
      # 5: Used for meta scope name (basically just non starred version)
      6:
        name: 'punctuation.definition.arguments.end.latex'
      7:
        name: 'punctuation.definition.arguments.optional.begin.latex'
      8:
        name: 'variable.parameter.optional.function.environment.latex'
      9:
        name: 'punctuation.definition.arguments.optional.end.latex'
    end: '((\\\\)end)(\\{)(\\4)(\\})'
    endCaptures:
      1:
        name: 'support.function.environment.end.latex'
      2:
        name: 'punctuation.definition.function.latex'
      3:
        name: 'punctuation.definition.arguments.begin.latex'
      4:
        name: 'variable.parameter.environment.latex'
      5:
        name: 'punctuation.definition.arguments.end.latex'
    patterns: [{ include: '$self' }]
  }
  metaEnvMath: {
    patterns: [
      {
        comment: 'Matches generic math environments'
        name: 'meta.environment.math.$5.latex'
        contentName: 'string.other.math.block.$5.latex'
        begin: '((\\\\)begin)(\\{)((align(ed)?|equation|multline|split|gather(ed)?)\\*?)(\\})(?:(\\[)(.*?)(\\]))?'
        beginCaptures:
          1:
            name: 'support.function.environment.begin.latex'
          2:
            name: 'punctuation.definition.function.begin.latex'
          3:
            name: 'punctuation.definition.arguments.begin.latex'
          4:
            name: 'variable.parameter.environment.$5.latex'
          # 5: Used for meta scope name (basically just non starred version)
          6:
            name: 'punctuation.definition.arguments.end.latex'
          7:
            name: 'punctuation.definition.arguments.optional.begin.latex'
          8:
            name: 'variable.parameter.optional.function.environment.latex'
          9:
            name: 'punctuation.definition.arguments.optional.end.latex'
        end: '((\\\\)end)(\\{)(\\4)(\\})'
        endCaptures:
          1:
            name: 'support.function.environment.end.latex'
          2:
            name: 'punctuation.definition.function.latex'
          3:
            name: 'punctuation.definition.arguments.begin.latex'
          4:
            name: 'variable.parameter.environment.latex'
          5:
            name: 'punctuation.definition.arguments.end.latex'
        patterns: [{ include: '$self' }]
      }
      {
        comment: 'Matches the alignat environment'
        name: 'meta.environment.math.$5.latex'
        contentName: 'string.other.math.block.$5.latex'
        begin: '((\\\\)begin)(\\{)((alignat)\\*?)(\\})(?:(\\{)(.*?)(\\}))?'
        beginCaptures:
          1:
            name: 'support.function.environment.begin.latex'
          2:
            name: 'punctuation.definition.function.begin.latex'
          3:
            name: 'punctuation.definition.arguments.begin.latex'
          4:
            name: 'variable.parameter.environment.$5.latex'
          # 5: Used for meta scope name (basically just non starred version)
          6:
            name: 'punctuation.definition.arguments.end.latex'
          7:
            name: 'punctuation.definition.arguments.begin.latex'
          8:
            name: 'variable.parameter.environment.latex'
            patterns: [
              { include: '#numericConstants' }
              { include: '$self' }] # This is amazing! It works!
          9:
            name: 'punctuation.definition.arguments.end.latex'
        end: '((\\\\)end)(\\{)(\\4)(\\})'
        endCaptures:
          1:
            name: 'support.function.environment.end.latex'
          2:
            name: 'punctuation.definition.function.latex'
          3:
            name: 'punctuation.definition.arguments.begin.latex'
          4:
            name: 'variable.parameter.environment.latex'
          5:
            name: 'punctuation.definition.arguments.end.latex'
        patterns: [{ include: '$self' }]
      }
    ]
  }
  envList: {
    comment: 'Matches itemize|enumerate|description environment'
    contentName: 'meta.environment.list.$5.latex'
    begin: '((\\\\)begin)(\\{)((itemize|enumerate|description)\\*?)(\\})(?:(\\[)(.*?)(\\]))?'
    beginCaptures:
      1:
        name: 'support.function.environment.begin.latex'
      2:
        name: 'punctuation.definition.function.begin.latex'
      3:
        name: 'punctuation.definition.arguments.begin.latex'
      4:
        name: 'variable.parameter.environment.$5.latex'
      # 5: Used for meta scope name (basically just non starred version)
      6:
        name: 'punctuation.definition.arguments.end.latex'
      7:
        name: 'punctuation.definition.arguments.optional.begin.latex'
      8:
        name: 'variable.parameter.optional.function.environment.latex'
      9:
        name: 'punctuation.definition.arguments.optional.end.latex'
    end: '((\\\\)end)(\\{)(\\4)(\\})'
    endCaptures:
      1:
        name: 'support.function.environment.end.latex'
      2:
        name: 'punctuation.definition.function.latex'
      3:
        name: 'punctuation.definition.arguments.begin.latex'
      4:
        name: 'variable.parameter.environment.latex'
      5:
        name: 'punctuation.definition.arguments.end.latex'
    patterns: [{ include: '$self' }]
  }
  envVerbatim: {
    comment: 'Matches verbatim environment.'
    name: 'meta.environment.verbatim.latex'
    contentName: 'markup.raw.verbatim.latex'
    begin: '((\\\\)begin)(\\{)((verbatim))(\\})(?:(\\[)(.*?)(\\]))?'
    beginCaptures:
      1:
        name: 'support.function.environment.begin.latex'
      2:
        name: 'punctuation.definition.function.begin.latex'
      3:
        name: 'punctuation.definition.arguments.begin.latex'
      4:
        name: 'variable.parameter.environment.$5.latex'
      # 5: Here to keep numbering consistent with other environments
      6:
        name: 'punctuation.definition.arguments.end.latex'
      7:
        name: 'punctuation.definition.arguments.optional.begin.latex'
      8:
        name: 'variable.parameter.optional.function.environment.latex'
      9:
        name: 'punctuation.definition.arguments.optional.end.latex'
    end: '((\\\\)end)(\\{)(\\4)(\\})'
    endCaptures:
      1:
        name: 'support.function.environment.end.latex'
      2:
        name: 'punctuation.definition.function.latex'
      3:
        name: 'punctuation.definition.arguments.begin.latex'
      4:
        name: 'variable.parameter.environment.latex'
      5:
        name: 'punctuation.definition.arguments.end.latex'
  }


  # Experimental
  unitMeasure: {
    comment: 'This will likely be merged into a different rule. Currently doesnt work.'
    name: 'constant.numeric.latex'
    match: '\\b((\\+|\\-)\\s*)?((\\d+(\\.|\\,)?)|(\\d*((\\.|\\,)\\d*)))\\s*(true\\s*)?(pt|pc|in|bp|cm|mm|dd|cc|sp|em|ex)\\b'
  }
  keywords: {
    comment: '''Taken from the TeXBook. Not sorted.
      at, bp, by, cc, cm, dd, depth, em, ex, fil, height, in, l, minus, mm, mu, pc, plus, pt, scaled, sp, spread, to, true, width
    '''
  }
  texPrimitives: {
    comment: 'This took a long time to write </joke>. Really though, dont even bother trying to edit it. Just add more primitives to the list in ../lib/resources, and recompile it.'
    name: 'entity.name.function.primitive.latex'
    match: '(\\\\)(((a(bove(displays(hortskip|kip)|withdelims)?|ccent|d(jdemerits|vance)|fter(assignment|group)|top(withdelims)?)|b(a(dness|selineskip|tchmode)|e(gingroup|lowdisplays(hortskip|kip))|inoppenalty|o(tmark|x(maxdepth)?)|rokenpenalty)|c(atcode|har(def)?|l(eaders|ose(in|out)|ubpenalty)|o(py|unt(def)?)|r(cr)?|sname)|d(ay|e(adcycles|f(ault(hyphenchar|skewchar))?|l(code|imiter(factor|shortfall)?))|i(men(def)?|s(cretionary|play(indent|limits|style|wid(owpenalty|th)))|vide)|oublehyphendemerits|p|ump)|e(def|lse|mergencystretch|nd(csname|group|input|linechar)?|qno|rr(help|message|or(contextlines|stopmode))|scapechar|very(cr|display|hbox|job|math|par|vbox)|x(hyphenpenalty|pandafter))|f(am|i(nalhyphendemerits|rstmark)?|loatingpenalty|ont(dimen|name)?|uturelet)|g(def|lobal(defs)?)|h(a(lign|ng(after|indent))|b(adness|ox)|f(il(l|neg)?|uzz)|o(ffset|ldinginserts)|rule|s(ize|kip|s)|t|yphen(ation|char|penalty))|i(f(ca(se|t)|dim|eof|false|h(box|mode)|inner|mmode|num|odd|true|v(box|mode|oid)|x)?|gnorespaces|mmediate|n(dent|put(lineno)?|sert(penalties)?|terlinepenalty))|jobname|kern|l(a(nguage|st(box|kern|penalty|skip))|ccode|e(aders|ft(hyphenmin|skip)?|qno|t)|i(mits|ne(penalty|skip(limit)?))|o(ng|oseness|wer(case)?))|m(a(g|rk|th(accent|bin|c(h(ar(def)?|oice)|lose|ode)|inner|o(p(en)?|rd)|punct|rel|surround)|xde(adcycles|pth))|e(aning|dmuskip|ssage)|kern|o(nth|ve(left|right))|skip|u(ltiply|skip(def)?))|n(ewlinechar|o(align|boundary|expand|indent|limits|ns(cript|topmode))|u(ll(delimiterspace|font)|mber))|o(mit|pen(in|out)|r|ut(er|put(penalty)?)|ver(fullrule|line|withdelims)?)|p(a(ge(depth|fil(l(lstretch|stretch)|stretch)|goal|s(hrink|tretch)|total)|r(fillskip|indent|s(hape|kip))?|tterns|using)|enalty|ostdisplaypenalty|re(display(penalty|size)|tolerance|v(depth|graf)))|r(a(dical|ise)|e(ad|l(ax|penalty))|ight(hyphenmin|skip)?|omannumeral)|s(cr(ipt(font|s(cript(font|style)|pace|tyle))|ollmode)|et(box|language)|fcode|h(ipout|ow(box(breadth|depth)?|lists|the)?)|k(ewchar|ip(def)?)|p(a(ce(factor|skip)|n)|ecial|lit(botmark|firstmark|maxdepth|topskip))|tring)|t(abskip|ext(font|style)|h(e|i(ckmuskip|nmuskip))|ime|o(ks(def)?|lerance|p(mark|skip))|racing(commands|lostchars|macros|o(nline|utput)|pa(ges|ragraphs)|restores|stats))|u(c(code|hyph)|n(derline|h(box|copy)|kern|penalty|skip|v(box|copy))|ppercase)|v(a(djust|lign)|b(adness|ox)|center|f(il(l|neg)?|uzz)|offset|rule|s(ize|kip|plit|s)|top)|w(d|idowpenalty|rite)|x(def|leaders|spaceskip)|year)(?=[^a-zA-Z]))|(\\s|\\-|\\/))'
  }
  pdfTexPrimitives: {
    comment: 'These dont apply on all engines, but I feel the names are specific enough and pdfLaTeX is used enough to justify it.'
    name: 'entity.name.function.primitive.pdftex.latex'
    match: '(\\\\)(pdf(o(ut(put|line)|bj(compresslevel)?)|m(inorversion|a(p(file|line)|tch)|ovechars|dfivesum)|c(o(mpresslevel|pyfont|lorstack(init)?)|atalog|reationdate)|d(e(cimaldigits|st(margin)?)|raftmode)|horigin|vorigin|p(age(width|height|sattr|attr|re(sources|f)|box)|k(resolution|mode)|r(otrudechars|ependkern|imitive)|xdimen)|i(n(fo(omitdate)?|clu(dechars|sion(errorlevel|copyfonts))|terwordspaceo(n|ff)|sertht)|gnoreddimen|mage(resolution|hicolor|applygamma|gamma))|s(uppress(ptexinfo|warning(dup(map|dest)|pagegroup))|t(artlink|rcmp)|et(randomseed|matrix)|ave(pos)?|hellescape)|n(ames|o(ligatures|builtintounicode|rmaldeviate))|t(ra(iler(id)?|cingfonts)|hread(margin)?|startthread|ex(banner|revision|version))|f(o(nt(expand|attr|name|objnum|size)|rcepagebox)|akespace|i(rstlineheight|le(moddate|size|dump)))|a(djust(spacing|interwordglue)|ppendkern|nnot)|un(i(queresname|formdeviate)|escapehex)|g(entounicode|lyphtounicode|amma)|l(ast(lin(edepth|k)|obj|x(form|image(colordepth|pages)?|pos)|annot|match|ypos)|i(nkmargin|teral))|e(achline(height|depth)|nd(link|thread)|scape(string|name|hex)|lapsedtime)|r(e(f(obj|x(form|image))|s(ettimer|tore)|tval)|andomseed)|x(form(name)?|image(bbox)?))|efcode|r(pcode|ightmarginkern)|l(pcode|e(ftmarginkern|tterspacefont))|tagcode|kn(b(scode|ccode)|accode)|s(tbscode|hbscode)|if(pdf(abs(num|dim)|primitive)|incsname)|quitvmode|vadjust)(?=[^a-zA-Z])'
  }
  unsortedPrimitives: {
    comment: 'Im not sure which engine first defined these, but they are all primitives in LaTeX'
    name: 'entity.name.function.primitive.latex'
    match: '(\\\\)(un(less|expanded)|botmarks|c(urrent(if(type|branch|level)|group(level|type))|lubpenalties)|p(a(gediscards|rshape(dimen|indent|length))|r(otected|edisplaydirection))|m(u(toglue|expr)|arks|iddle)|d(i(splaywidowpenalties|mexpr)|etokenize)|f(ontchar(ic|dp|ht|wd)|irstmarks)|widowpenalties|t(racing(ifs|assigns|scantokens|nesting|groups)|opmarks)|i(f(fontchar|defined|csname)|nter(linepenalties|actionmode))|s(how(groups|tokens|ifs)|plit(firstmarks|botmarks|discards)|aving(vdiscards|hyphcodes)|cantokens)|glue(expr|tomu|s(hrink(order)?|tretch(order)?))|e(veryeof|TeX(version|revision))|readline|last(nodetype|linefit)|numexpr)(?=[^a-zA-Z])'
  }
  doubleCaret: {
    comment: 'Im not sure what these are called, but they seem to work (eg. ^^M is a linebreak)'
    name: 'constant.character.latex'
    match: '\\^\\^(\\d+|.|$)'
  }
  text: {
    begin: '((\\\\)text)\\s*(\\{)'
    beginCaptures:
      1:
        name: 'support.function.text.latex'
      2:
        name: 'punctuation.definition.function.latex'
      3:
        name: 'punctuation.definition.arguments.begin.latex'
    end: '\\}'
    endCaptures:
      0:
        name: 'punctuation.definition.arguments.end.latex'
    contentName: 'variable.parameter.latex'
    patterns: [{ include: '$self' }]
  }
  constants: {
    comment: 'Taken from language-latex'
    match: '(\\\\)(text(s(terling|ixoldstyle|urd|e(ction|venoldstyle|rvicemark))|yen|n(ineoldstyle|umero|aira)|c(ircledP|o(py(left|right)|lonmonetary)|urrency|e(nt(oldstyle)?|lsius))|t(hree(superior|oldstyle|quarters(emdash)?)|i(ldelow|mes)|w(o(superior|oldstyle)|elveudash)|rademark)|interrobang(down)?|zerooldstyle|o(hm|ne(superior|half|oldstyle|quarter)|penbullet|rd(feminine|masculine))|d(i(scount|ed|v(orced)?)|o(ng|wnarrow|llar(oldstyle)?)|egree|agger(dbl)?|blhyphen(char)?)|uparrow|p(ilcrow|e(so|r(t(housand|enthousand)|iodcentered))|aragraph|m)|e(stimated|ightoldstyle|uro)|quotes(traight(dblbase|base)|ingle)|f(iveoldstyle|ouroldstyle|lorin|ractionsolidus)|won|l(not|ira|e(ftarrow|af)|quill|angle|brackdbl)|a(s(cii(caron|dieresis|acute|grave|macron|breve)|teriskcentered)|cutedbl)|r(ightarrow|e(cipe|ferencemark|gistered)|quill|angle|brackdbl)|g(uarani|ravedbl)|m(ho|inus|u(sicalnote)?|arried)|b(igcircle|orn|ullet|lank|a(ht|rdbl)|rokenbar)))(?![a-zA-Z@])'
    captures:
      0:
        name: 'constant.character.latex'
      1:
        name: 'punctuation.definition.constant.latex'
  }
  numericConstants: {
    comment: 'To match numbers of form 12, 1.2, etc.'
    match: '(\\d*\\.\\d+|(\\d+\\.)?\\d*)'
    name: 'constant.numeric.math.latex'
  }

# Unfortunate necessity (mainly making a unique grammar for each coding language)

# Removed
  controlWordWithAt: {
    comment: 'To be used when @ is a letter'
    name: 'support.function.general.latex'
    match: '\\\\[a-zA-Z@]+'
  }
  underscoreWithArgument: {
    comment: 'Matches an underscore and between curly brackets'
    name: 'punctuation.subscript.latex'
    begin: '_\\s*(?={)'
    end: '(?<=\\})'
    patterns: [
      { include: '#argumentScope' }
    ]
  }
  underscoreNoArgument: {
    comment: 'Matches an underscore and next character or macro. Considering making this give a warning, as brackets is best practice'
    name: 'punctuation.subscript.latex'
    match: '_\\s*(\\\\[a-zA-Z]+|\\\\[.]|.)?'
  }
  caretWithArgument: {
    comment: 'Matches a caret and between curly brackets'
    name: 'markup.other.superscript.latex'
    begin: '\\^\\s*'
    beginCaptures:
      0:
        name: 'punctuation.superscript.latex'
    end: '(?<=[^\\^])'
    patterns: [
      { include: '$self' }
    ]
  }
  caretNoArgument: {
    comment: 'Matches a caret and next character or macro. Considering making this give a warning, as brackets is best practice'
    name: 'punctuation.superscript.latex'
    match: '\\^\\s*(\\\\[a-zA-Z]+|\\\\[.]|.)?'
  }
  endArgumentsMeta: {
    patterns: [
      { include: '#doubleBackslash' }
      { include: '#escapedCurlyBracket' }
    ]
  }
